<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hormetic Alignment - Opponent Process Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Tailwind gray-900 */
            color: #e2e8f0; /* Tailwind gray-200 */
        }
        .param-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 1rem; }
        .param-container { display: flex; flex-direction: column; margin-bottom: 0.5rem; } /* Renamed from slider-container */
        .param-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.875rem;
            color: #a0aec0; /* Tailwind gray-400 */
            margin-bottom: 0.25rem;
        }
        .value-input-group {
            display: flex;
            align-items: center;
        }
         .number-input {
             background-color: #2d3748; /* Tailwind gray-800 */
             border-color: #4a5568; /* Tailwind gray-600 */
             color: #e2e8f0; /* Tailwind gray-200 */
             padding: 0.25rem 0.5rem;
             border-radius: 0.25rem;
             width: 6rem; /* Fixed width for number inputs */
             margin-left: 0.5rem; /* Space between label text and input */
             text-align: right; /* Align text to the right */
         }
         .number-input::-webkit-inner-spin-button,
         .number-input::-webkit-outer-spin-button {
             -webkit-appearance: none;
             margin: 0;
         }
         .number-input {
             -moz-appearance: textfield;
         }

        .plot-container {
            width: 100%;
            background-color: #2d3748; /* Tailwind gray-800 */
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.3), 0 2px 4px -1px rgba(0,0,0,0.2);
            padding: 1rem;
            margin-bottom: 1.5rem;
             /* Containers are hidden by default and shown when plots are drawn */
             display: none;
             /* Adjusted height for larger graphs */
             min-height: 400px; /* Minimum height */
             max-height: 600px; /* Maximum height before scrolling */
             overflow-y: auto; /* Add scroll if content exceeds max-height */
        }
         /* Ensure canvas inside container takes available height */
         .plot-container canvas {
             height: 100% !important;
             width: 100% !important;
         }

        input[type="range"] {
            -webkit-appearance: none; appearance: none; width: 100%; height: 8px;
            background: #4a5568; /* Tailwind gray-600 */
            border-radius: 9999px; outline: none; opacity: 0.8; transition: opacity .2s;
            margin-top: 0.25rem;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 18px; height: 18px;
            background: #63b3ed; /* Tailwind blue-400 */
            border-radius: 50%; cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 18px; height: 18px;
            background: #63b3ed; /* Tailwind blue-400 */
            border-radius: 50%; cursor: pointer; border:0;
        }

        h1 { color: #cbd5e0; /* Tailwind gray-300 */}
        h2 { font-size: 1.25rem; font-weight: 600; margin-bottom: 0.75rem; color: #cbd5e0; /* Tailwind gray-300 */ border-bottom-color: #4a5568; }
        h3 { font-size: 1.1rem; font-weight: 500; margin-top: 1rem; margin-bottom: 0.5rem; color: #cbd5e0; /* Tailwind gray-300 */}
        label.text-sm { color: #a0aec0; /* Tailwind gray-400 */ }
        button { transition: background-color 0.2s ease-in-out; }
    </style>
</head>
<body class="p-4 md:p-8">
    <div class="max-w-7xl mx-auto">
        <header class="mb-8 text-center">
            <h1 class="text-3xl font-bold">Opponent Process Model Simulator</h1>
            <p class="text-gray-500">Adjust parameters and observe the shift in PK/PD dynamics.</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <div class="lg:col-span-1 bg-gray-800 p-6 rounded-lg shadow-xl space-y-6 overflow-y-auto" style="max-height: 90vh;">
                <h2 class="text-xl font-semibold border-b pb-2">Simulation Parameters</h2>

                <button id="runSimulation" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md">Run Simulation</button>
                <button id="resetDefaults" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md mt-2">Reset to Defaults</button>

                <h3>General Settings</h3>
                <div class="param-container">
                    <label for="sim_length_input" class="param-label">
                        Simulation Length (min):
                        <input type="number" id="sim_length_input" class="number-input" value="4000" step="100">
                    </label>
                    <input type="range" id="sim_length_slider" min="100" max="10000" value="4000" step="100">
                </div>
                <div class="param-container">
                    <label for="infuse_input" class="param-label">
                        Infusion Duration (min):
                        <input type="number" id="infuse_input" class="number-input" value="1" step="0.1">
                    </label>
                    <input type="range" id="infuse_slider" min="0.1" max="10" value="1" step="0.1">
                </div>

                <h3>Clearance Rates (k)</h3>
                <div class="param-grid">
                    <div class="param-container">
                        <label for="k_Dose_input" class="param-label">
                            k_Dose:
                            <input type="number" id="k_Dose_input" class="number-input" value="1" step="0.01">
                        </label>
                        <input type="range" id="k_Dose_slider" min="0.01" max="5" value="1" step="0.01">
                    </div>
                    <div class="param-container">
                        <label for="k_apk_input" class="param-label">
                            k_apk:
                            <input type="number" id="k_apk_input" class="number-input" value="0.02" step="0.001">
                        </label>
                        <input type="range" id="k_apk_slider" min="0.001" max="0.5" value="0.02" step="0.001">
                    </div>
                    <div class="param-container">
                        <label for="k_bpk_input" class="param-label">
                            k_bpk:
                            <input type="number" id="k_bpk_input" class="number-input" value="0.004" step="0.001">
                        </label>
                        <input type="range" id="k_bpk_slider" min="0.001" max="0.1" value="0.004" step="0.001">
                    </div>
                    <div class="param-container">
                        <label for="k_apd_input" class="param-label">
                            k_apd:
                            <input type="number" id="k_apd_input" class="number-input" value="1" step="0.1">
                        </label>
                        <input type="range" id="k_apd_slider" min="0.1" max="5" value="1" step="0.1">
                    </div>
                    <div class="param-container">
                        <label for="k_bpd_input" class="param-label">
                            k_bpd:
                            <input type="number" id="k_bpd_input" class="number-input" value="1" step="0.1">
                        </label>
                        <input type="range" id="k_bpd_slider" min="0.1" max="5" value="1" step="0.1">
                    </div>
                    <div class="param-container">
                        <label for="k_H_input" class="param-label">
                            k_H:
                            <input type="number" id="k_H_input" class="number-input" value="1" step="0.1">
                        </label>
                        <input type="range" id="k_H_slider" min="0.1" max="5" value="1" step="0.1">
                    </div>
                </div>

                <h3>A-Process PD</h3>
                <div class="param-grid">
                    <div class="param-container">
                         <label for="E0_a_input" class="param-label">
                            E0_a:
                            <input type="number" id="E0_a_input" class="number-input" value="0" step="0.01">
                        </label>
                        <input type="range" id="E0_a_slider" min="0" max="1" value="0" step="0.01">
                    </div>
                    <div class="param-container">
                        <label for="Emax_a_input" class="param-label">
                            Emax_a:
                             <input type="number" id="Emax_a_input" class="number-input" value="1" step="0.1">
                        </label>
                        <input type="range" id="Emax_a_slider" min="0" max="5" value="1" step="0.1">
                    </div>
                    <div class="param-container">
                        <label for="EC50_a_input" class="param-label">
                            EC50_a:
                            <input type="number" id="EC50_a_input" class="number-input" value="1" step="0.1">
                        </label>
                        <input type="range" id="EC50_a_slider" min="0.1" max="20" value="1" step="0.1">
                    </div>
                    <div class="param-container">
                        <label for="gamma_a_input" class="param-label">
                            gamma_a:
                            <input type="number" id="gamma_a_input" class="number-input" value="2" step="0.1">
                        </label>
                        <input type="range" id="gamma_a_slider" min="0.1" max="10" value="2" step="0.1">
                    </div>
                </div>

                <h3>B-Process PD</h3>
                <div class="param-grid">
                    <div class="param-container">
                        <label for="E0_b_input" class="param-label">
                            E0_b:
                             <input type="number" id="E0_b_input" class="number-input" value="0" step="0.01">
                        </label>
                        <input type="range" id="E0_b_slider" min="0" max="1" value="0" step="0.01">
                    </div>
                    <div class="param-container">
                        <label for="Emax_b_input" class="param-label">
                            Emax_b:
                             <input type="number" id="Emax_b_input" class="number-input" value="3" step="0.1">
                        </label>
                        <input type="range" id="Emax_b_slider" min="0" max="10" value="3" step="0.1">
                    </div>
                    <div class="param-container">
                        <label for="EC50_b_input" class="param-label">
                            EC50_b:
                            <input type="number" id="EC50_b_input" class="number-input" value="9" step="0.1">
                        </label>
                        <input type="range" id="EC50_b_slider" min="0.1" max="50" value="9" step="0.1">
                    </div>
                    <div class="param-container">
                        <label for="gamma_b_input" class="param-label">
                            gamma_b:
                            <input type="number" id="gamma_b_input" class="number-input" value="2" step="0.1">
                        </label>
                        <input type="range" id="gamma_b_slider" min="0.1" max="10" value="2" step="0.1">
                    </div>
                </div>

                <h3>BFRA Settings</h3>
                 <div class="param-container">
                    <label for="plot_biophase_cb" class="text-sm flex items-center justify-between w-full">
                        <span>Plot Biophase Curves:</span>
                        <input type="checkbox" id="plot_biophase_cb" checked class="form-checkbox h-5 w-5 text-blue-500 rounded">
                    </label>
                </div>
                <div class="param-container">
                    <label for="plot_bfra_graph_cb" class="text-sm flex items-center justify-between w-full">
                        <span>Plot BFRA Graph:</span>
                        <input type="checkbox" id="plot_bfra_graph_cb" checked class="form-checkbox h-5 w-5 text-blue-500 rounded">
                    </label>
                </div>
                <div class="param-container">
                    <label for="seq_1_input" class="param-label">
                        BFRA Freq. Resolution (seq_1):
                         <input type="number" id="seq_1_input" class="number-input" value="0.0002" step="0.0001">
                    </label>
                    <input type="range" id="seq_1_slider" min="0.0001" max="0.005" value="0.0002" step="0.0001">
                </div>
                <div class="param-container">
                    <label for="seq_2_input" class="param-label">
                        BFRA Freq. Max (seq_2):
                         <input type="number" id="seq_2_input" class="number-input" value="0.01" step="0.001">
                    </label>
                    <input type="range" id="seq_2_slider" min="0.001" max="0.1" value="0.01" step="0.001">
                </div>
                 <div class="param-container">
                    <label for="plot_2_freq_input" class="param-label">
                        H(t) Plot Freq:
                         <input type="number" id="plot_2_freq_input" class="number-input" value="0.01" step="0.0001" min="0.000001"> </label>
                </div>
                <div class="param-container">
                    <label for="gg_ylim_min_input" class="param-label">
                        BFRA Y-axis Min (optional):
                        <input type="number" id="gg_ylim_min_input" class="number-input" placeholder="e.g., -1000">
                    </label>
                </div>
            </div>

            <div class="lg:col-span-2 space-y-6 overflow-y-auto" style="max-height: 90vh;">
                <div id="hPlotContainer" class="plot-container">
                    <h3 class="text-center">Hedonic State (H) vs. Time</h3>
                    <canvas id="hPlotCanvas"></canvas>
                </div>
                <div id="apdPlotContainer" class="plot-container">
                    <h3 class="text-center">A-Process Biophase (apd vs. apk)</h3>
                    <canvas id="apdPlotCanvas"></canvas>
                </div>
                <div id="bpdPlotContainer" class="plot-container">
                    <h3 class="text-center">B-Process Biophase (bpd vs. bpk)</h3>
                    <canvas id="bpdPlotCanvas"></canvas>
                </div>
                <div id="bodePlotContainer" class="plot-container">
                    <h3 class="text-center">BFRA: Steady-state Hedonic State vs. Frequency</h3>
                    <canvas id="bodePlotCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Chart instances ---
        const chartInstances = {};
        const plotLineColor1 = '#63b3ed'; // Tailwind blue-400
        const plotLineColor2 = '#4fd1c5'; // Tailwind teal-400
        const gridLineColor = '#4a5568'; // Tailwind gray-600
        const labelColor = '#e2e8f0';    // Tailwind gray-200

        // Set Chart.js defaults for dark mode
        Chart.defaults.color = labelColor;
        Chart.defaults.borderColor = gridLineColor;
        Chart.defaults.plugins.tooltip.enabled = false; // Disable tooltips globally
        Chart.defaults.hover.mode = null; // Disable hover effects globally


        // --- Default Parameters ---
        const defaultParams = {
            sim_length: 4000, infuse: 1,
            k_Dose: 1, k_apk: 0.02, k_bpk: 0.004, k_apd: 1, k_bpd: 1, k_H: 1,
            E0_a: 0, Emax_a: 1, EC50_a: 1, gamma_a: 2,
            E0_b: 0, Emax_b: 3, EC50_b: 9, gamma_b: 2,
            plot_biophase_cb: true, plot_bfra_graph_cb: true,
            seq_1: 0.0002, seq_2: 0.01,
            plot_2_freq: 0.01, // H(t) plot frequency
            gg_ylim_min: "" // Optional BFRA Y-axis min
        };

        // --- Simulation Time Step ---
        // Adjusting this value can affect simulation accuracy (especially with discrete events) and performance.
        // Smaller values increase accuracy but take longer to run.
        // If you see alternating peak heights in the H(t) plot, this might be related to the step size
        // interacting with dose timing, but if reducing it doesn't help, the cause is likely elsewhere.
        const dt_ode = 0.5; // Minutes

        // --- UI Setup ---
        function setupUI() {
            // Parameters that have both slider and number input (using _slider and _input suffixes)
            const dualInputParams = [
                "sim_length", "infuse", "k_Dose", "k_apk", "k_bpk", "k_apd", "k_bpd", "k_H",
                "E0_a", "Emax_a", "EC50_a", "gamma_a", "E0_b", "Emax_b", "EC50_b", "gamma_b",
                "seq_1", "seq_2"
            ];

            dualInputParams.forEach(id => {
                const slider = document.getElementById(id + "_slider");
                const numberInput = document.getElementById(id + "_input");

                if (slider && numberInput) {
                    // Sync number input -> slider -> validation
                    numberInput.addEventListener("input", () => {
                         let value = parseFloat(numberInput.value);

                         // Update number input value (basic NaN check) - keep original input string if not a valid number yet
                         if (isNaN(value)) {
                             // Don't change the number input's displayed value yet if it's not a number during typing
                             // Validation will happen in getParamsFromUI
                             return;
                         }


                        // Sync slider if value is within slider's range
                         const sliderMin = parseFloat(slider.min);
                         const sliderMax = parseFloat(slider.max);

                         if (!isNaN(sliderMin) && !isNaN(sliderMax)) {
                            if (value >= sliderMin && value <= sliderMax) {
                                slider.value = value;
                            } else if (value < sliderMin) {
                                 slider.value = sliderMin; // Clamp slider to min visually
                             } else { // value > sliderMax
                                slider.value = sliderMax; // Clamp slider to max visually
                             }
                         }
                         // If value is outside slider range, slider stays at its limit, number input shows actual value.
                         // No need to re-set numberInput.value here, it's already updated by user input.

                    });

                    // Sync slider -> number input
                    slider.addEventListener("input", () => {
                        // Slider value is always within its defined range
                        numberInput.value = slider.value;
                    });
                }
            });

            // Parameters that only have a number input (using original IDs + _input suffix now)
            const plot2FreqInput = document.getElementById("plot_2_freq_input");
            if (plot2FreqInput) {
                plot2FreqInput.addEventListener("input", () => {
                     // Basic NaN check, validation against min happens in getParamsFromUI
                     let value = parseFloat(plot2FreqInput.value);
                      if (isNaN(value) && plot2FreqInput.value !== "") {
                           // Don't change the number input's displayed value yet if it's not a number during typing
                           return;
                     }
                 });
            }

            const ggYlimMinInput = document.getElementById("gg_ylim_min_input");
            if (ggYlimMinInput) {
                ggYlimMinInput.addEventListener("input", () => {
                    // Allow number or empty string
                     let value = ggYlimMinInput.value === "" ? "" : parseFloat(ggYlimMinInput.value);
                    if (isNaN(value) && ggYlimMinInput.value !== "") {
                        // Don't change the number input's displayed value yet if it's not a number during typing
                        return;
                    }
                });
            }


            document.getElementById("runSimulation").addEventListener("click", runFullBFRA);
            document.getElementById("resetDefaults").addEventListener("click", resetAllDefaults);

            setParamsToUI(defaultParams); // Initialize UI with defaults
             // No need to clear plots initially, containers are hidden by default
        }

        // Sets the UI elements (sliders and number inputs) based on a params object
        function setParamsToUI(params) {
            const allParamKeys = Object.keys(defaultParams);

            allParamKeys.forEach(key => {
                 const slider = document.getElementById(key + "_slider");
                 const numberInput = document.getElementById(key + "_input");
                 const checkbox = document.getElementById(key); // For checkboxes using original ID

                 if (numberInput) {
                     // Set value for number input
                     if (key === "gg_ylim_min") {
                          numberInput.value = params[key] === null ? "" : params[key]; // Handle null for optional input
                     } else {
                         numberInput.value = params[key];
                     }

                     // Sync corresponding slider if it exists and the value is within its range
                     if (slider) {
                          const sliderMin = parseFloat(slider.min);
                          const sliderMax = parseFloat(slider.max);
                          const value = parseFloat(numberInput.value); // Use the value set in the number input

                         if (!isNaN(sliderMin) && !isNaN(sliderMax) && !isNaN(value)) {
                            if (value >= sliderMin && value <= sliderMax) {
                                slider.value = value;
                            } else if (value < sliderMin) {
                                 slider.value = sliderMin; // Clamp slider to min visually
                             } else { // value > sliderMax
                                slider.value = sliderMax; // Clamp slider to max visually
                             }
                         }
                     }
                 } else if (checkbox && checkbox.type === "checkbox") {
                     // Set checked state for checkbox
                      checkbox.checked = params[key];
                 }
                 // Fallback for elements without _input suffix (shouldn't happen with new HTML)
                 else if (document.getElementById(key)) {
                      const el = document.getElementById(key);
                      if (el.type === "checkbox") params[key] = el.checked;
                      else if (el.type === "number" || el.type === "range") params[key] = parseFloat(el.value);
                      else params[key] = el.value;
                 } else {
                     // Use default if element not found (shouldn't happen)
                     params[key] = defaultParams[key];
                 }
            });
        }

        // Resets all UI elements to their default values and clears plots
        function resetAllDefaults() {
             console.log("Resetting to defaults...");
            setParamsToUI(defaultParams);
            clearAllPlots();
             console.log("Defaults reset.");
        }

        // Gets parameter values from UI elements (prioritizes number inputs)
        function getParamsFromUI() {
             console.log("Getting parameters from UI...");
            const params = {};
            const allParamKeys = Object.keys(defaultParams);

            allParamKeys.forEach(key => {
                 const numberInput = document.getElementById(key + "_input");
                 const checkbox = document.getElementById(key); // For checkboxes

                 if (numberInput) {
                     // Always get value from number input
                     let value = parseFloat(numberInput.value);

                     // *** Input Validation and Clamping for Simulation Use ***
                     if (key === "gg_ylim_min") {
                          params[key] = isNaN(value) ? null : value; // Optional, allow null
                     } else if (key === "plot_2_freq") {
                           // Frequency must be positive
                          const min = parseFloat(numberInput.min) || 0; // Get min from HTML if present, default to 0
                          params[key] = isNaN(value) || !isFinite(value) || value <= 0 ? defaultParams.plot_2_freq : value;
                          if (params[key] <= 0) params[key] = defaultParams.plot_2_freq; // Ensure it's > 0 for division
                     } else if (['k_Dose', 'k_apk', 'k_bpk', 'k_apd', 'k_bpd', 'k_H'].includes(key)) {
                          // Rates must be non-negative finite numbers
                          params[key] = isNaN(value) || !isFinite(value) || value < 0 ? defaultParams[key] : value;
                          if (params[key] < 0) params[key] = 0; // Ensure non-negative
                          if (!isFinite(params[key])) params[key] = defaultParams[key]; // Ensure finite
                     } else if (['Emax_a', 'Emax_b', 'EC50_a', 'EC50_b', 'gamma_a', 'gamma_b', 'E0_a', 'E0_b'].includes(key)) {
                          // PD parameters must be finite. Emax/gamma non-negative, EC50 non-negative. E0 can be any finite number.
                           if (isNaN(value) || !isFinite(value)) {
                               params[key] = defaultParams[key];
                           } else {
                                // Removed clamping here:
                                // if (['Emax_a', 'Emax_b', 'gamma_a', 'gamma_b'].includes(key)) {
                                //     params[key] = Math.max(0, value); // Ensure non-negative
                                // } else if (['EC50_a', 'EC50_b'].includes(key)) {
                                //     params[key] = Math.max(0, value); // Ensure non-negative (EC50 can be 0)
                                // } else { // E0_a, E0_b
                                //     params[key] = value; // Can be negative or positive
                                // }
                                params[key] = value; // Keep raw value from input
                           }
                            if (!isFinite(params[key])) params[key] = defaultParams[key]; // Final check for finite
                      }
                       else if (['sim_length', 'infuse'].includes(key)) {
                          // sim_length and infuse must be non-negative finite numbers
                           params[key] = isNaN(value) || !isFinite(value) || value < 0 ? defaultParams[key] : value;
                            if (params[key] < 0) params[key] = 0; // Ensure non-negative
                           if (!isFinite(params[key])) params[key] = defaultParams[key]; // Ensure finite
                       }
                       else if (['seq_1', 'seq_2'].includes(key)) {
                           // BFRA range parameters must be non-negative finite numbers
                            params[key] = isNaN(value) || !isFinite(value) || value < 0 ? defaultParams[key] : value;
                             if (params[key] < 0) params[key] = 0; // Ensure non-negative
                            if (!isFinite(params[key])) params[key] = defaultParams[key]; // Ensure finite
                       }
                       else {
                          // Fallback for any other number inputs - just ensure finite
                           params[key] = isNaN(value) || !isFinite(value) ? defaultParams[key] : value;
                       }

                 } else if (checkbox && checkbox.type === "checkbox") {
                     // Get checked state for checkbox
                     params[key] = checkbox.checked;
                 }
                 // Fallback for elements without _input suffix (shouldn't happen with new HTML)
                 else if (document.getElementById(key)) {
                      const el = document.getElementById(key);
                      if (el.type === "checkbox") params[key] = el.checked;
                      else if (el.type === "number" || el.type === "range") params[key] = parseFloat(el.value);
                      else params[key] = el.value;
                 } else {
                     // Use default if element not found (shouldn't happen)
                     params[key] = defaultParams[key];
                 }
            });

            // Additional validation/correction for BFRA range after getting all values
            if (params.plot_bfra_graph_cb) { // Only check/warn if BFRA plotting is enabled
                if (params.seq_1 <= 0 || params.seq_2 <= 0 || params.seq_2 < params.seq_1) {
                     console.warn(`Invalid BFRA frequency range: seq_1=${params.seq_1}, seq_2=${params.seq_2}. Disabling BFRA plot.`);
                    params.plot_bfra_graph_cb = false; // Disable BFRA plot if range is invalid
                } else {
                     console.log(`BFRA frequency range: seq_1=${params.seq_1}, seq_2=${params.seq_2}`);
                }
            }


             console.log("Got parameters (validated):", params);
            return params;
        }


        // --- ODE Solver (RK4) ---

        // Helper function to calculate PD effect using the Emax model, handling EC50=0 and invalid inputs
        const calculatePDEffect = (pk_conc, E0, Emax, EC50, gamma) => {
             // Removed clamping here:
             // // Ensure PK concentration is a non-negative finite number
             // if (isNaN(pk_conc) || !isFinite(pk_conc) || pk_conc < 0) {
             //     // console.warn(`  calculatePDEffect: Received invalid PK concentration ${pk_conc}. Treating as 0.`); // Too chatty
             //     pk_conc = 0;
             // }
              // Ensure parameters are finite numbers (basic check, more thorough in getParamsFromUI)
             if (isNaN(E0) || !isFinite(E0) || isNaN(Emax) || !isFinite(Emax) || isNaN(EC50) || !isFinite(EC50) || isNaN(gamma) || !isFinite(gamma)) {
                  console.error("calculatePDEffect: Received non-finite parameters. E0:", E0, "Emax:", Emax, "EC50:", EC50, "Gamma:", gamma);
                 return isFinite(E0) ? E0 : 0; // Return baseline effect (or 0 if E0 is also bad) on invalid parameters
             }


             // Handle EC50 = 0 case: effect is E0 + Emax if concentration > 0, else E0
             if (EC50 === 0) {
                 return pk_conc > 0 ? E0 + Emax : E0;
             }

             // Handle EC50 > 0 case
             // Be careful with Math.pow(negative, non-integer) - though pk_conc is clamped to >= 0
             // Math.pow(0, 0) is 1, Math.pow(positive, 0) is 1, Math.pow(0, positive) is 0
             // Removed clamping here: const pk_conc_pow_gamma = (pk_conc === 0 && gamma === 0) ? 1 : (pk_conc === 0 && gamma > 0) ? 0 : Math.pow(Math.max(0, pk_conc), gamma);
             const pk_conc_pow_gamma = (pk_conc === 0 && gamma === 0) ? 1 : (pk_conc === 0 && gamma > 0) ? 0 : Math.pow(pk_conc, gamma);

             const ec50_pow_gamma = (EC50 === 0 && gamma === 0) ? 1 : (EC50 === 0 && gamma > 0) ? 0 : Math.pow(EC50, gamma);


             // Handle potential division by zero
             const denominator = ec50_pow_gamma + pk_conc_pow_gamma;
             if (denominator === 0) {
                 // This could potentially happen if both EC50 and pk_conc are 0 and gamma > 0, leading to 0/0.
                 // Or if both are 0 and gamma = 0, leading to 1/2 (valid).
                 // Given the clamp and EC50=0 check, this path should be rare, but as a fallback:
                  // console.warn("Denominator is zero in PD effect calculation (EC50>0 case). PK:", pk_conc, "EC50:", EC50, "Gamma:", gamma); // Too chatty
                 return E0; // Return baseline effect if denominator is zero
             }

             const num = Emax * pk_conc_pow_gamma;
             const effect_contribution = num / denominator;

              // Check if the calculated effect contribution is finite
             if (!isFinite(effect_contribution)) {
                 console.error("calculatePDEffect: Calculated effect contribution is not finite.", {num, denominator, effect_contribution, pk_conc, EC50, gamma});
                 return isFinite(E0) ? E0 : 0; // Return baseline (or 0) if calculation results in non-finite number
             }


             const result = E0 + effect_contribution;
             // console.log(`  calculatePDEffect: Result = ${result.toFixed(4)}`); // Too chatty with RK4 steps
             return result;
         };


        function derivatives(t, y, p, currentInputRate) {
             // console.log(`Calling derivatives at t=${t.toFixed(2)} with y=[${y.map(v => v.toFixed(4)).join(', ')}], inputRate=${currentInputRate.toFixed(4)}`); // Too chatty

            const [Dose, apk, bpk, apd, bpd, H] = y;

             // Check for non-finite state variables before calculation
             if (!y.every(v => isFinite(v))) {
                 console.error("Derivatives input 'y' contains non-finite values:", y, "at t=", t);
                 // Return zero derivatives to prevent system from exploding further
                 return [0, 0, 0, 0, 0, 0];
             }


            const dDose_dt = currentInputRate - p.k_Dose * Dose; // Use Dose for clearance
            const dapk_dt = p.k_Dose * Dose - p.k_apk * apk; // Use Dose, apk
            const dbpk_dt = p.k_apk * apk - p.k_bpk * bpk; // Use apk, bpk

            // PD effects based on potentially clamped PK states using the helper
            // Removed clamping here:
            // const safe_apk = Math.max(0, y[1]);
            // const safe_bpk = Math.max(0, y[2]);
            const apd_effect = calculatePDEffect(y[1], p.E0_a, p.Emax_a, p.EC50_a, p.gamma_a);
            const dapad_dt = apd_effect - p.k_apd * apd;

            const bpd_effect = calculatePDEffect(y[2], p.E0_b, p.Emax_b, p.EC50_b, p.gamma_b);
            const dbpd_dt = bpd_effect - p.k_bpd * bpd;

            const dH_dt = p.k_apd * apd - p.k_bpd * bpd - p.k_H * H;

             const results = [dDose_dt, dapk_dt, dbpk_dt, dapad_dt, dbpd_dt, dH_dt];

              // Check for non-finite derivative results
             if (!results.every(v => isFinite(v))) {
                 console.error("Derivatives output contains non-finite values:", results, "at t=", t, "input y=", y);
                 // Return zero derivatives to prevent RK4 from propagating NaN/Infinity
                 return [0, 0, 0, 0, 0, 0];
             }

             // console.log(`Derivatives at t=${t.toFixed(2)}: [${results.map(v => v.toFixed(4)).join(', ')}]`); // Too chatty
            return results;
        }

        function rk4Step(t, y, dt, p, currentInputRate) {
            let k1 = derivatives(t, y, p, currentInputRate);
            // Removed clamping here:
            // let y2 = y.map((yi, i) => Math.max(0, yi + 0.5 * dt * k1[i]));
            let y2 = y.map((yi, i) => yi + 0.5 * dt * k1[i]);
            let k2 = derivatives(t + 0.5 * dt, y2, p, currentInputRate);
            // Removed clamping here:
            // let y3 = y.map((yi, i) => Math.max(0, yi + 0.5 * dt * k2[i]));
            let y3 = y.map((yi, i) => yi + 0.5 * dt * k2[i]);
            let k3 = derivatives(t + 0.5 * dt, y3, p, currentInputRate);
            // Removed clamping here:
            // let y4 = y.map((yi, i) => Math.max(0, yi + dt * k3[i]));
            let y4 = y.map((yi, i) => yi + dt * k3[i]);
            let k4 = derivatives(t + dt, y4, p, currentInputRate);

            let next_y = y.map((yi, i) => yi + (dt / 6) * (k1[i] + 2 * k2[i] + 2 * k3[i] + k4[i]));

             // Explicitly clamp relevant states at 0 after the step to prevent negative values
             // REMOVED CLAMPING HERE TO TEST IF IT CAUSES ALTERNATING PEAKS
            // next_y[0] = Math.max(0, next_y[0]); // Dose
            // next_y[1] = Math.max(0, next_y[1]); // apk
            // next_y[2] = Math.max(0, next_y[2]); // bpk
            // apd, bpd, H can be negative based on the model equations, so don't clamp them.

            return next_y; // Return next_y without post-step clamping
        }


        function runSingleODESimulation(params, sim_length, ii, infuse, dose_amt = 1) {
            console.log(`Running ODE sim: Length=${params.sim_length}, II=${ii}, Infuse=${params.infuse}, dt=${dt_ode}`);
            let y = [0, 0, 0, 0, 0, 0]; // Initial conditions [Dose, apk, bpk, apd, bpd, H]
            let currentTime = 0;

            // Store data points at every ODE step for smoother plotting
            const dataPoints = [{
                 t: 0,
                 H: y[5],
                 apk: y[1],
                 bpk: y[2],
                 apd: y[3],
                 bpd: y[4]
            }];

             // Pre-calculate and refine dose times
            const doseTimes = [];
            if (ii > 0) {
                 let currentDoseTime = 0;
                 // Generate dose times up to sim_length plus a buffer for infusions ending slightly after the end time
                 while (currentDoseTime <= params.sim_length + params.infuse + dt_ode * 2) {
                     const roundedTime = parseFloat(currentDoseTime.toFixed(10));
                     doseTimes.push(roundedTime);
                     currentDoseTime += ii;
                 }
            } else { // Handle single bolus at time 0 if ii is 0 or negative
                doseTimes.push(0);
            }
             const uniqueDoseTimes = Array.from(new Set(doseTimes)).sort((a,b) => a - b);
             console.log("Calculated Unique Dose Times:", uniqueDoseTimes);

            let doseTimeIndex = 0;


            while (currentTime < params.sim_length) {
                 let currentInputRate = 0;

                 // --- Dose Triggering Logic ---
                 // Check if the next scheduled dose time has arrived or just passed
                 if (doseTimeIndex < uniqueDoseTimes.length) {
                     const scheduledTime = uniqueDoseTimes[doseTimeIndex];
                     const tolerance = dt_ode * 1e-6;

                     // If the current time step lands on or just past the scheduled time
                     if (currentTime >= scheduledTime - tolerance) {
                         // *** Trigger the dose action ***
                         if (params.infuse > 0) {
                             // Infusion Starts
                             console.log(`Scheduled infusion start detected at ${scheduledTime.toFixed(2)}.`);
                             // The input rate logic will handle this in subsequent steps

                             // Record state *at* the infusion start time if this step is the trigger
                             // Push the state *before* the RK4 step integrates from this point
                              dataPoints.push({
                                 t: currentTime, // Use currentTime as the step time where trigger occurred
                                 H: y[5], apk: y[1], bpk: y[2], apd: y[3], bpd: y[4]
                             });


                         } else {
                             // Bolus dose - add amount now
                             y[0] += dose_amt;
                             console.log(`Administering bolus at time ${currentTime.toFixed(2)} (scheduled: ${scheduledTime.toFixed(2)})`);

                             // Record state *immediately after* bolus administration (at this time step)
                             dataPoints.push({
                                 t: currentTime, // Use currentTime as the step time where bolus was added
                                 H: y[5], apk: y[1], bpk: y[2], apd: y[3], bpd: y[4]
                             });
                         }
                         // Move to the next scheduled dose time *after* triggering this one
                         doseTimeIndex++; // Crucial for triggering each dose only once
                     }
                 }

                 // *** Determine the instantaneous input rate for the current time step ***
                 instantaneousInputRate = 0;
                  if (params.infuse > 0 && doseTimeIndex > 0) {
                     const lastTriggeredDoseTime = uniqueDoseTimes[doseTimeIndex - 1];
                     const infusionEndTime = lastTriggeredDoseTime + params.infuse;
                     const tolerance = dt_ode * 1e-6;

                     // Check if the current time is within the window of the last triggered infusion
                     if (currentTime >= lastTriggeredDoseTime - tolerance && currentTime < infusionEndTime + tolerance) {
                          instantaneousInputRate = dose_amt / params.infuse;
                     }

                     // Explicitly add a plotting point at the infusion end time or the step closest to it
                     // Check if the *next* step will cross or land on the infusion end time
                     if (currentTime < infusionEndTime && currentTime + dt_ode >= infusionEndTime) {
                          // Record state *at* the infusion end time (or the current step closest to it)
                          dataPoints.push({
                              t: currentTime, // Use currentTime as the step just before/at the end
                              H: y[5], apk: y[1], bpk: y[2], apd: y[3], bpd: y[4]
                          });
                           console.log(`Recording state near infusion end time: ${infusionEndTime.toFixed(2)} at sim time ${currentTime.toFixed(2)}.`);
                     }
                 }


                 // Check for non-finite state variables before calling derivatives
                if (!y.every(v => isFinite(v))) {
                    console.error("State variables 'y' contain non-finite values before calling derivatives:", y, "at t=", currentTime);
                    break; // Exit loop on invalid state
                }

                y = rk4Step(currentTime, y, dt_ode, params, instantaneousInputRate);

                currentTime += dt_ode;

                // --- Plotting Data Recording (at every ODE step) ---
                 // Record point if it's within the simulation length and not the initial point already added
                 // This will drastically increase the number of data points for smoother plots.
                 // May impact performance for very long simulations.
                 if (currentTime <= params.sim_length && currentTime > 0) {
                      // Ensure we don't add duplicate points if a dose trigger or infusion end already added a point at this time step
                      const lastRecordedTime = dataPoints.length > 0 ? dataPoints[dataPoints.length - 1].t : -Infinity; // Get last recorded time, handle empty array
                      const plotTolerance = dt_ode * 1e-4; // Tolerance for checking if time is already recorded

                     if (Math.abs(currentTime - lastRecordedTime) > plotTolerance) {
                          dataPoints.push({
                              t: currentTime,
                              H: y[5], apk: y[1], bpk: y[2], apd: y[3], bpd: y[4]
                          });
                     }
                 }
            }
             console.log("ODE sim finished. Raw data points collected:", dataPoints.length);

             // Ensure unique and sorted times after simulation
             // This step is still necessary to handle points added at dose/infusion times and interval times which might overlap or be very close
             const uniqueSortedDataPoints = [];
             if (dataPoints.length > 0) {
                 // Sort all collected points by time
                 dataPoints.sort((a, b) => a.t - b.t);

                 // Add the first point
                 if (isFinite(dataPoints[0].t) && isFinite(dataPoints[0].H) && isFinite(dataPoints[0].apk) && isFinite(dataPoints[0].bpk) && isFinite(dataPoints[0].apd) && isFinite(dataPoints[0].bpd)) {
                     uniqueSortedDataPoints.push(dataPoints[0]);
                 } else {
                     console.warn("Skipping initial non-finite data point:", dataPoints[0]);
                 }


                 const timeTolerance = dt_ode * 1e-4; // Tolerance for considering times unique
                 for (let i = 1; i < dataPoints.length; i++) {
                      // Check for NaN/Infinity first
                      if (!isFinite(dataPoints[i].t) || !isFinite(dataPoints[i].H) || !isFinite(dataPoints[i].apk) || !isFinite(dataPoints[i].bpk) || !isFinite(dataPoints[i].apd) || !isFinite(dataPoints[i].bpd)) {
                          console.warn("Skipping non-finite data point during unique filtering:", dataPoints[i]);
                          continue; // Skip this point
                      }

                     // If current point is significantly after the last unique point, add it
                     if (dataPoints[i].t - uniqueSortedDataPoints[uniqueSortedDataPoints.length - 1].t > timeTolerance) {
                          uniqueSortedDataPoints.push(dataPoints[i]);
                     } else {
                         // If times are effectively the same, keep the later one (potentially better state from end of interval)
                         uniqueSortedDataPoints[uniqueSortedDataPoints.length - 1] = dataPoints[i];
                     }
                 }
             }


             const finalTimes = uniqueSortedDataPoints.map(item => item.t);
             const finalH_values = uniqueSortedDataPoints.map(item => item.H);
             const finalApk_values = uniqueSortedDataPoints.map(item => item.apk);
             const finalBpk_values = uniqueSortedDataPoints.map(item => item.bpk);
             const finalApd_values = uniqueSortedDataPoints.map(item => item.apd);
             const finalBpd_values = uniqueSortedDataPoints.map(item => item.bpd);


             // Final check for non-finite data
             if (!finalTimes.every(v => isFinite(v)) || !finalH_values.every(v => isFinite(v)) || !finalApk_values.every(v => isFinite(v)) || !finalBpk_values.every(v => isFinite(v)) || !finalApd_values.every(v => isFinite(v)) || !finalBpd_values.every(v => isFinite(v))) {
                  console.error("ODE simulation produced arrays with non-finite values after unique/sort.");
                 return { times: [], H_values: [], apk_values: [], bpk_values: [], apd_values: [], bpd_values: [] }; // Return empty arrays if data is invalid
             }

             console.log("Final data points after processing:", finalTimes.length);

            return { times: finalTimes, H_values: finalH_values, apk_values: finalApk_values, bpk_values: finalBpk_values, apd_values: finalApd_values, bpd_values: finalBpd_values };
        }


        // --- Simulation and BFRA Logic ---
        function runFullBFRA() {
            console.log("Run Simulation clicked");
            const params = getParamsFromUI(); // Get validated parameters
            console.log("Parameters:", params);

            clearAllPlots(); // Clear previous charts and hide containers

            const plotData = {
                hPlot: null,
                apdPlot: null,
                bpdPlot: null,
                bodePlot: null // BFRA data
            };

            // --- Run ODE Simulation for H(t) Plot ---
            console.log("Running H(t) simulation...");
            // Use validated params.plot_2_freq and params.sim_length
            if (params.plot_2_freq > 0 && params.sim_length > 0) {
                 const ii_for_h_plot = 1 / params.plot_2_freq;
                 // Pass validated params, sim_length, ii, infuse, and dose_amt (default is 1)
                 const simResults_h = runSingleODESimulation(params, params.sim_length, ii_for_h_plot, params.infuse, 1);

                 if (simResults_h && simResults_h.times.length > 0) {
                      // Check for invalid data (NaN, Infinity) in results before plotting
                      const hasInvalidData = simResults_h.H_values.some(v => !isFinite(v)) ||
                                             simResults_h.apk_values.some(v => !isFinite(v)) ||
                                             simResults_h.bpk_values.some(v => !isFinite(v)) ||
                                             simResults_h.apd_values.some(v => !isFinite(v)) ||
                                             simResults_h.bpd_values.some(v => !isFinite(v));

                      if (!hasInvalidData) {
                           // Include all relevant simulation results in plotData.hPlot
                           plotData.hPlot = {
                               times: simResults_h.times,
                               H_values: simResults_h.H_values,
                               apk_values: simResults_h.apk_values,
                               bpk_values: simResults_h.bpk_values,
                               apd_values: simResults_h.apd_values,
                               bpd_values: simResults_h.bpd_values,
                               freq: params.plot_2_freq
                           };
                            console.log("H(t) simulation data generated and assigned to plotData.hPlot.");
                      } else {
                          console.error("H(t) simulation produced invalid data (NaN or Infinity). Skipping H(t) plot and using default biophase range.");
                           // Optionally display an error message to the user
                      }

                 } else {
                      console.warn("H(t) simulation returned no data points or results object is invalid. Using default biophase range.");
                 }
            } else {
                 console.warn("H(t) Plot Frequency (plot_2_freq) is zero or negative, or simulation length is zero. Skipping H(t) simulation.");
            }


            // --- Calculate Biophase Data (Dose-Response Curves) ---
            console.log("Calculating Biophase data...");
            // Use validated params.plot_biophase_cb
            if (params.plot_biophase_cb) {
                 // Determine appropriate max concentration based on H plot sim results (if available and valid) or defaults
                 const simApkValues = plotData.hPlot?.apk_values; // Use optional chaining for safer access
                 const simBpkValues = plotData.hPlot?.bpk_values; // Use optional chaining for safer access

                 const max_apk = Math.max(
                     defaultParams.EC50_a * 5, // Base range on EC50
                     (simApkValues && simApkValues.length > 0 && simApkValues.every(v => isFinite(v))) ? Math.max(...simApkValues) * 1.2 : defaultParams.EC50_a * 10, // Use sim max if valid
                     1 // Ensure min 1
                 );
                 const max_bpk = Math.max(
                     defaultParams.EC50_b * 5, // Base range on EC50
                     (simBpkValues && simBpkValues.length > 0 && simBpkValues.every(v => isFinite(v))) ? Math.max(...simBpkValues) * 1.2 : defaultParams.EC50_b * 10, // Use sim max if valid
                     1 // Ensure min 1
                 );

                 const pk_conc_max = Math.max(max_apk, max_bpk, 50); // Ensure a reasonable overall max, min 50
                 const pk_conc_step = pk_conc_max / 200; // Generate 200 points for smoother curves

                const pk_conc_seq = [];
                for (let c = 0; c <= pk_conc_max; c += pk_conc_step) pk_conc_seq.push(c);

                 if (pk_conc_seq.length > 0) {
                     // Use validated parameters in calculatePDEffect
                     const apd_bio_values = pk_conc_seq.map(apk_conc => calculatePDEffect(apk_conc, params.E0_a, params.Emax_a, params.EC50_a, params.gamma_a));
                     const bpd_bio_values = pk_conc_seq.map(bpk_conc => calculatePDEffect(bpk_conc, params.E0_b, params.Emax_b, params.EC50_b, params.gamma_b));

                      // Check for invalid data
                     const hasInvalidBioData = apd_bio_values.some(v => !isFinite(v)) || bpd_bio_values.some(v => !isFinite(v));

                     if (!hasInvalidBioData) {
                          plotData.apdPlot = { pk_concs: pk_conc_seq, pd_effects: apd_bio_values };
                          plotData.bpdPlot = { pk_concs: pk_conc_seq, pd_effects: bpd_bio_values };
                          console.log("Biophase data generated.");
                     } else {
                         console.error("Biophase calculation produced invalid data (NaN or Infinity). Skipping biophase plots.");
                     }

                 } else {
                      console.warn("PK concentration sequence for biophase plot is empty.");
                 }
            } else {
                 console.log("Biophase plot checkbox is unchecked. Skipping calculation.");
            }


            // --- Calculate BFRA (Analytical Steady-state) Data ---
            console.log("Calculating BFRA data...");
            // Use validated parameters
            if (params.plot_bfra_graph_cb && params.seq_1 > 0 && params.seq_2 >= params.seq_1) {
                 const bode_analytical_data = { freqs: [], h_analytical_values: [] };
                 const tolerance = params.seq_1 * 1e-6; // Tolerance for frequency generation

                 for (let freq = params.seq_1; freq <= params.seq_2 + tolerance; freq += params.seq_1) {
                     const ii = 1 / freq;
                     // Check for ii being a non-zero finite number
                     if (isNaN(ii) || !isFinite(ii) || ii <= 0) continue;

                     // Analytical steady-state PK concentrations for chronic dosing (Assuming Dose=1)
                     // Use validated k_apk, k_bpk, k_Dose
                     let apk_analytic_conc = (params.k_Dose <= 0 || params.k_apk <= 0 || ii <= 0) ? 0 : (1 / ii) / params.k_apk; // Corrected division by zero/non-positive k/ii
                     let bpk_analytic_conc = (params.k_Dose <= 0 || params.k_bpk <= 0 || ii <= 0) ? 0 : (1 / ii) / params.k_bpk; // Corrected division by zero/non-positive k/ii


                     // Ensure analytical concentrations are finite and non-negative
                     // Removed clamping here:
                     // apk_analytic_conc = isFinite(apk_analytic_conc) ? Math.max(0, apk_analytic_conc) : 0;
                     // bpk_analytic_conc = isFinite(bpk_analytic_conc) ? Math.max(0, bpk_analytic_conc) : 0;
                      apk_analytic_conc = isFinite(apk_analytic_conc) ? apk_analytic_conc : 0;
                      bpk_analytic_conc = isFinite(bpk_analytic_conc) ? bpk_analytic_conc : 0;


                     // Analytical Steady-state PD effects based on analytical PK concentrations
                     // Use validated PD parameters
                     const term_a_pd_ss = calculatePDEffect(apk_analytic_conc, params.E0_a, params.Emax_a, params.EC50_a, params.gamma_a);
                     const term_b_pd_ss = calculatePDEffect(bpk_analytic_conc, params.E0_b, params.Emax_b, params.EC50_b, params.gamma_b);

                     // Analytical Steady-state Hedonic State
                     // Use validated k_H
                     let H_steady_state = (params.k_H <= 0) ? (term_a_pd_ss - term_b_pd_ss) : (term_a_pd_ss - term_b_pd_ss) / params.k_H; // Corrected division by zero/non-positive k_H

                     // Ensure steady state H is finite
                      H_steady_state = isFinite(H_steady_state) ? H_steady_state : (isFinite(term_a_pd_ss) && isFinite(term_b_pd_ss) ? (term_a_pd_ss - term_b_pd_ss) : 0); // Fallback


                      // Plotting Steady-state H vs Frequency
                      bode_analytical_data.freqs.push(freq);
                      bode_analytical_data.h_analytical_values.push(H_steady_state);
                 }

                 // Sort analytical data by frequency and ensure unique points
                 if (bode_analytical_data.freqs.length > 0) {
                      // Check for invalid data before sorting/storing
                     const hasInvalidBodeData = bode_analytical_data.h_analytical_values.some(v => !isFinite(v));

                     if (!hasInvalidBodeData) {
                           const sortedFreqs = bode_analytical_data.freqs.map((f, i) => ({ freq: f, value: bode_analytical_data.h_analytical_values[i] }))
                                                                .sort((a, b) => a.freq - b.freq);

                            // Filter for unique frequencies using a tolerance
                             const uniqueSorted = [];
                             if (sortedFreqs.length > 0) {
                                uniqueSorted.push(sortedFreqs[0]);
                                 const freqTolerance = params.seq_1 * 1e-3; // Tolerance for considering frequencies unique (slightly larger than seq_1_tolerance)
                                 for (let i = 1; i < sortedFreqs.length; i++) {
                                     if (sortedFreqs[i].freq - uniqueSorted[uniqueSorted.length - 1].freq > freqTolerance) {
                                         uniqueSorted.push(sortedFreqs[i]);
                                     }
                                 }
                             }


                            plotData.bodePlot = {
                                analytical: {
                                     freqs: uniqueSorted.map(item => item.freq),
                                     h_analytical_values: uniqueSorted.map(item => item.value)
                                }
                            };
                            console.log("BFRA analytical data generated.");
                     } else {
                         console.error("BFRA analytical calculation produced invalid data (NaN or Infinity). Skipping BFRA plot.");
                     }

                 } else {
                      console.warn("BFRA frequency sequence is empty.");
                 }

            } else {
                 console.log("BFRA plot checkbox is unchecked or frequency range is invalid. Skipping calculation.");
            }

            console.log("Calling updateAllCharts with plotData:", plotData);
            updateAllCharts(plotData, params);
            console.log("Run Simulation finished.");
        }

        // --- Charting ---
        // Initializes or updates a Chart.js instance
        function initOrUpdateChart(canvasId, chartType, data, options, instanceKey) {
            console.log(`Attempting to draw chart: ${instanceKey} on canvas: ${canvasId}`);
            const canvas = document.getElementById(canvasId);
            if (!canvas) {
                console.error(`Canvas element not found: ${canvasId}`);
                return; // Exit if canvas is not found
            }
            const ctx = canvas.getContext('2d');
             if (!ctx) {
                 console.error(`Could not get 2D context for canvas: ${canvasId}`);
                 return; // Exit if context is not available
             }

            if (chartInstances[instanceKey]) {
                console.log(`Destroying existing chart instance: ${instanceKey}`);
                chartInstances[instanceKey].destroy();
                chartInstances[instanceKey] = null;
            }

            try {
                chartInstances[instanceKey] = new Chart(ctx, { type: chartType, data, options });
                console.log(`Chart ${instanceKey} created successfully.`);
                 // Show the container since a chart was successfully created
                const containerId = canvasId.replace('Canvas', 'Container');
                const container = document.getElementById(containerId);
                if (container) {
                    container.style.display = 'block';
                    console.log(`Container ${containerId} displayed.`);
                }
            } catch (error) {
                console.error(`Error creating chart ${instanceKey}:`, error);
                 // Hide container if chart creation fails
                const containerId = canvasId.replace('Canvas', 'Container');
                const container = document.getElementById(containerId);
                if (container) {
                    container.style.display = 'none';
                     console.log(`Container ${containerId} hidden due to error.`);
                }
            }
        }

        // Destroys a chart instance and hides its container
        function clearChart(instanceKey) {
             console.log(`Attempting to clear chart: ${instanceKey}`);
            const containerId = instanceKey.replace('Chart', 'Container');
            const container = document.getElementById(containerId);

            if (chartInstances[instanceKey]) {
                console.log(`Destroying chart instance for clearing: ${instanceKey}`);
                chartInstances[instanceKey].destroy();
                chartInstances[instanceKey] = null;
                console.log(`Chart ${instanceKey} destroyed.`);
            } else {
                console.log(`No active chart instance found for clearing: ${instanceKey}`);
            }

            // Hide the container when the chart is cleared or if there was no chart
            if (container) {
                container.style.display = 'none';
                console.log(`Container ${containerId} hidden.`);
            } else {
                console.warn(`Container not found for chart clearing: ${containerId}`);
            }
        }

        // Clears all plot instances and hides their containers
        function clearAllPlots() {
             console.log("Clearing all plots...");
            // Destroy all chart instances first
            for (const key in chartInstances) {
                if (chartInstances[key]) {
                    try {
                        chartInstances[key].destroy();
                         console.log(`Destroyed chart instance: ${key}`);
                    } catch(e) {
                        console.error(`Error destroying chart instance ${key}:`, e);
                    }
                    chartInstances[key] = null;
                }
            }
             // Explicitly hide all plot containers
             const plotContainers = document.querySelectorAll('.plot-container');
             plotContainers.forEach(container => {
                 container.style.display = 'none';
                  console.log(`Hid container: ${container.id}`);
             });
             console.log("All plots cleared.");
        }


        function updateAllCharts(plotData, params) {
            console.log("Inside updateAllCharts");
            const commonScaleOptions = (xLabel, yLabel, yScaleOverrides = {}) => ({
                x: { title: { display: true, text: xLabel, color: labelColor }, ticks: { color: labelColor }, grid: { color: gridLineColor } },
                y: { title: { display: true, text: yLabel, color: labelColor }, ticks: { color: labelColor }, grid: { color: gridLineColor }, ...yScaleOverrides }
            });

            // H vs Time Plot
             console.log("Attempting H plot update. Data present:", !!plotData.hPlot, "Data length:", plotData.hPlot?.times.length);
             if (plotData.hPlot && plotData.hPlot.times.length > 0) {
                 initOrUpdateChart('hPlotCanvas', 'line', {
                     labels: plotData.hPlot.times.map(t => t.toFixed(t < 10 && t % 1 !== 0 ? 1 : 0)), // Format time ticks intelligently
                     datasets: [{
                         label: `H(t) at freq ${plotData.hPlot.freq.toFixed(4)} min⁻¹`,
                         data: plotData.hPlot.H_values,
                         borderColor: plotLineColor1,
                         borderWidth: 2, fill: false, pointRadius: 0
                     },
                     // Adding apk, bpk, apd, bpd to the H(t) plot for easier comparison
                     {
                         label: 'apk',
                         data: plotData.hPlot.apk_values,
                         borderColor: '#f6e05e', // Tailwind yellow-400
                         borderWidth: 1, fill: false, pointRadius: 0, hidden: true // Hide by default
                     },
                     {
                         label: 'bpk',
                         data: plotData.hPlot.bpk_values,
                         borderColor: '#fc8181', // Tailwind red-400
                         borderWidth: 1, fill: false, pointRadius: 0, hidden: true // Hide by default
                     },
                     {
                         label: 'apd',
                         data: plotData.hPlot.apd_values,
                         borderColor: '#68d391', // Tailwind green-400
                         borderWidth: 1, fill: false, pointRadius: 0, hidden: true // Hide by default
                     },
                      {
                         label: 'bpd',
                         data: plotData.hPlot.bpd_values,
                         borderColor: '#f6ad55', // Tailwind orange-400
                         borderWidth: 1, fill: false, pointRadius: 0, hidden: true // Hide by default
                     }
                    ]
                 }, {
                     responsive: true,
                     maintainAspectRatio: true,
                     scales: commonScaleOptions('Time (min)', 'Magnitude (arb. units)') // Changed Y-axis label
                 }, 'hPlotChart');
             } else {
                 clearChart('hPlotChart');
             }


            // Biophase Plots
            console.log("Attempting Biophase plot updates. Checkbox:", params.plot_biophase_cb, "Data present:", !!plotData.apdPlot, !!plotData.bpdPlot, "Data length:", plotData.apdPlot?.pk_concs.length);
            if (params.plot_biophase_cb && plotData.apdPlot && plotData.bpdPlot && plotData.apdPlot.pk_concs.length > 0) {
                initOrUpdateChart('apdPlotCanvas', 'line', {
                    labels: plotData.apdPlot.pk_concs.map(c => c.toFixed(c < 10 && c % 1 !== 0 ? 1 : 0)), // Format concentration ticks intelligently
                    datasets: [{
                        label: 'A-Process PD Effect',
                        data: plotData.apdPlot.pd_effects,
                        borderColor: plotLineColor1,
                        borderWidth: 2, fill: false, pointRadius: 0
                    }]
                }, {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: commonScaleOptions('apk Concentration (arb. units)', 'PD Effect (hedons)')
                }, 'apdPlotChart');

                initOrUpdateChart('bpdPlotCanvas', 'line', {
                    labels: plotData.bpdPlot.pk_concs.map(c => c.toFixed(c < 10 && c % 1 !== 0 ? 1 : 0)), // Format concentration ticks intelligently
                    datasets: [{
                        label: 'B-Process PD Effect',
                        data: plotData.bpdPlot.pd_effects,
                        borderColor: plotLineColor2,
                        borderWidth: 2, fill: false, pointRadius: 0
                    }]
                }, {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: commonScaleOptions('bpk Concentration (arb. units)', 'PD Effect (hedons)')
                }, 'bpdPlotChart');
            } else {
                clearChart('apdPlotChart');
                clearChart('bpdPlotChart');
            }


            // BFRA Plot
             console.log("Attempting BFRA plot update. Checkbox:", params.plot_bfra_graph_cb, "Data present:", !!plotData.bodePlot, "Data length:", plotData.bodePlot?.analytical?.freqs.length);
             // Only plot if checkbox is checked AND there is valid data
             if (params.plot_bfra_graph_cb && plotData.bodePlot && plotData.bodePlot.analytical.freqs.length > 0) {
                 const bodeDatasets = [];

                 // Analytical data is generated regardless of k_apd/k_bpd, but the analytical solution
                 // is only strictly correct for steady state conditions with continuous infusion at average rate.
                 // Plot it if analytical data was generated and is valid.
                 if (plotData.bodePlot.analytical && plotData.bodePlot.analytical.freqs.length > 0) {
                     bodeDatasets.push({
                         label: 'Steady-state Solution (Analytical)',
                         data: plotData.bodePlot.analytical.h_analytical_values.map((val, i) => ({
                              x: plotData.bodePlot.analytical.freqs[i],
                              y: val
                         })),
                         borderColor: plotLineColor1,
                         borderWidth: 2, fill: false, pointRadius: 4,
                         showLine: true // Ensure lines are drawn between points
                     });
                 }


                const bodeOptions = {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        x: {
                            type: 'linear', // Use linear scale for frequency
                            title: { display: true, text: 'Frequency (min⁻¹)', color: labelColor },
                            ticks: { color: labelColor, callback: function(value, index, values) {
                                // Determine appropriate precision based on the minimum frequency
                                const minFreq = params.seq_1 > 0 ? params.seq_1 : 0.0001; // Use validated seq_1
                                const precision = Math.max(0, -Math.floor(Math.log10(minFreq)) + 2); // e.g., 0.0001 -> 6 decimal places
                                return value.toFixed(precision);
                            }},
                            grid: { color: gridLineColor }
                        },
                        y: {
                            title: { display: true, text: 'Steady-state Hedonic State', color: labelColor }, // Title changed based on plotting H_steady_state directly
                            position: 'left',
                            ticks: { color: labelColor },
                            grid: { color: gridLineColor },
                            min: params.gg_ylim_min !== null ? params.gg_ylim_min : undefined
                         }
                     },
                 };

                 // Only initialize/update if there are datasets to plot
                 if (bodeDatasets.length > 0) {
                      initOrUpdateChart('bodePlotCanvas', 'line', {
                           // Chart.js scatter/line charts with linear x-axis use data points as {x, y} objects, not labels array
                           datasets: bodeDatasets
                      }, bodeOptions, 'bodePlotChart');
                 } else {
                     clearChart('bodePlotChart'); // Clear if no datasets
                 }


             } else {
                 clearChart('bodePlotChart');
             }
              console.log("updateAllCharts finished.");
        }


        // --- Initialization ---
        document.addEventListener("DOMContentLoaded", setupUI);

    </script>
</body>
</html>
